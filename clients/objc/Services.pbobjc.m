// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: services.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Services.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ServicesRoot

@implementation ServicesRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ServicesRoot_FileDescriptor

static GPBFileDescriptor *ServicesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - AssignRoles

@implementation AssignRoles

@dynamic userName;
@dynamic permissionsArray, permissionsArray_Count;
@dynamic rolesArray, rolesArray_Count;
@dynamic meta, meta_Count;

typedef struct AssignRoles__storage_ {
  uint32_t _has_storage_[1];
  NSString *userName;
  NSMutableArray *permissionsArray;
  NSMutableArray *rolesArray;
  NSMutableDictionary *meta;
} AssignRoles__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = AssignRoles_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssignRoles__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permissionsArray",
        .dataTypeSpecific.className = NULL,
        .number = AssignRoles_FieldNumber_PermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AssignRoles__storage_, permissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rolesArray",
        .dataTypeSpecific.className = NULL,
        .number = AssignRoles_FieldNumber_RolesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AssignRoles__storage_, rolesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = AssignRoles_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AssignRoles__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssignRoles class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssignRoles__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001H\000\002\000Permissions\000\003\000Roles\000\004D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AssignRolesResponse

@implementation AssignRolesResponse

@dynamic allRolesArray, allRolesArray_Count;
@dynamic allPermissionsArray, allPermissionsArray_Count;
@dynamic meta, meta_Count;
@dynamic hasResponseStatus, responseStatus;

typedef struct AssignRolesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *allRolesArray;
  NSMutableArray *allPermissionsArray;
  NSMutableDictionary *meta;
  ResponseStatus *responseStatus;
} AssignRolesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "allRolesArray",
        .dataTypeSpecific.className = NULL,
        .number = AssignRolesResponse_FieldNumber_AllRolesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AssignRolesResponse__storage_, allRolesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "allPermissionsArray",
        .dataTypeSpecific.className = NULL,
        .number = AssignRolesResponse_FieldNumber_AllPermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AssignRolesResponse__storage_, allPermissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = AssignRolesResponse_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AssignRolesResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = AssignRolesResponse_FieldNumber_ResponseStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssignRolesResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssignRolesResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssignRolesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\000AllRoles\000\002\000AllPermissions\000\003D\000\004N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Authenticate

@implementation Authenticate

@dynamic provider;
@dynamic state;
@dynamic oauthToken;
@dynamic oauthVerifier;
@dynamic userName;
@dynamic password;
@dynamic rememberMe;
@dynamic continue_p;
@dynamic errorView;
@dynamic nonce;
@dynamic uri;
@dynamic response;
@dynamic qop;
@dynamic nc;
@dynamic cnonce;
@dynamic useTokenCookie;
@dynamic accessToken;
@dynamic accessTokenSecret;
@dynamic scope;
@dynamic meta, meta_Count;

typedef struct Authenticate__storage_ {
  uint32_t _has_storage_[1];
  NSString *provider;
  NSString *state;
  NSString *oauthToken;
  NSString *oauthVerifier;
  NSString *userName;
  NSString *password;
  NSString *continue_p;
  NSString *errorView;
  NSString *nonce;
  NSString *uri;
  NSString *response;
  NSString *qop;
  NSString *nc;
  NSString *cnonce;
  NSString *accessToken;
  NSString *accessTokenSecret;
  NSString *scope;
  NSMutableDictionary *meta;
} Authenticate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "provider",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Provider,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Authenticate__storage_, provider),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Authenticate__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oauthToken",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_OauthToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Authenticate__storage_, oauthToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oauthVerifier",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_OauthVerifier,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Authenticate__storage_, oauthVerifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_UserName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Authenticate__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Password,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Authenticate__storage_, password),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rememberMe",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_RememberMe,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "continue_p",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Continue_p,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Authenticate__storage_, continue_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "errorView",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_ErrorView,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Authenticate__storage_, errorView),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Nonce,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Authenticate__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uri",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Uri,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Authenticate__storage_, uri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "response",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Response,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Authenticate__storage_, response),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qop",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Qop,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Authenticate__storage_, qop),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nc",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Nc,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Authenticate__storage_, nc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cnonce",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Cnonce,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Authenticate__storage_, cnonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "useTokenCookie",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_UseTokenCookie,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "accessToken",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_AccessToken,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(Authenticate__storage_, accessToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accessTokenSecret",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_AccessTokenSecret,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(Authenticate__storage_, accessTokenSecret),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scope",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Scope,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(Authenticate__storage_, scope),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = Authenticate_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Authenticate__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Authenticate class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Authenticate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\002E\000\005H\000\006H\000\007J\000\010\000Continue\000\tI\000\020N\000\021K\000\022Q\000\024D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthenticateResponse

@implementation AuthenticateResponse

@dynamic userId;
@dynamic sessionId;
@dynamic userName;
@dynamic displayName;
@dynamic referrerURL;
@dynamic bearerToken;
@dynamic refreshToken;
@dynamic profileURL;
@dynamic rolesArray, rolesArray_Count;
@dynamic permissionsArray, permissionsArray_Count;
@dynamic hasResponseStatus, responseStatus;
@dynamic meta, meta_Count;

typedef struct AuthenticateResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *sessionId;
  NSString *userName;
  NSString *displayName;
  NSString *referrerURL;
  NSString *bearerToken;
  NSString *refreshToken;
  NSString *profileURL;
  NSMutableArray *rolesArray;
  NSMutableArray *permissionsArray;
  ResponseStatus *responseStatus;
  NSMutableDictionary *meta;
} AuthenticateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_DisplayName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, displayName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "referrerURL",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_ReferrerURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, referrerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bearerToken",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_BearerToken,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, bearerToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refreshToken",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_RefreshToken,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, refreshToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "profileURL",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_ProfileURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, profileURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rolesArray",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_RolesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, rolesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permissionsArray",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_PermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, permissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = AuthenticateResponse_FieldNumber_ResponseStatus,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = AuthenticateResponse_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AuthenticateResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthenticateResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthenticateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\014\001F\000\002I\000\003H\000\004K\000\005I!!\000\006K\000\007L\000\010H!!\000\t\000Roles\000\n\000P"
        "ermissions\000\013N\000\014D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConvertSessionToToken

@implementation ConvertSessionToToken

@dynamic preserveSession;
@dynamic meta, meta_Count;

typedef struct ConvertSessionToToken__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *meta;
} ConvertSessionToToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "preserveSession",
        .dataTypeSpecific.className = NULL,
        .number = ConvertSessionToToken_FieldNumber_PreserveSession,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = ConvertSessionToToken_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConvertSessionToToken__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConvertSessionToToken class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConvertSessionToToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001O\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConvertSessionToTokenResponse

@implementation ConvertSessionToTokenResponse

@dynamic meta, meta_Count;
@dynamic accessToken;
@dynamic refreshToken;
@dynamic hasResponseStatus, responseStatus;

typedef struct ConvertSessionToTokenResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *meta;
  NSString *accessToken;
  NSString *refreshToken;
  ResponseStatus *responseStatus;
} ConvertSessionToTokenResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = ConvertSessionToTokenResponse_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConvertSessionToTokenResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accessToken",
        .dataTypeSpecific.className = NULL,
        .number = ConvertSessionToTokenResponse_FieldNumber_AccessToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConvertSessionToTokenResponse__storage_, accessToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refreshToken",
        .dataTypeSpecific.className = NULL,
        .number = ConvertSessionToTokenResponse_FieldNumber_RefreshToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConvertSessionToTokenResponse__storage_, refreshToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = ConvertSessionToTokenResponse_FieldNumber_ResponseStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConvertSessionToTokenResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConvertSessionToTokenResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConvertSessionToTokenResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001D\000\002K\000\003L\000\004N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateTodo

@implementation CreateTodo

@dynamic title;
@dynamic order;

typedef struct CreateTodo__storage_ {
  uint32_t _has_storage_[1];
  int32_t order;
  NSString *title;
} CreateTodo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = CreateTodo_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateTodo__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "order",
        .dataTypeSpecific.className = NULL,
        .number = CreateTodo_FieldNumber_Order,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateTodo__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateTodo class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateTodo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateTodoResponse

@implementation CreateTodoResponse

@dynamic hasResult, result;
@dynamic hasResponseStatus, responseStatus;

typedef struct CreateTodoResponse__storage_ {
  uint32_t _has_storage_[1];
  Todo *result;
  ResponseStatus *responseStatus;
} CreateTodoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = GPBStringifySymbol(Todo),
        .number = CreateTodoResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateTodoResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = CreateTodoResponse_FieldNumber_ResponseStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateTodoResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateTodoResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateTodoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001F\000\002N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteTodo

@implementation DeleteTodo

@dynamic id_p;

typedef struct DeleteTodo__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} DeleteTodo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = DeleteTodo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeleteTodo__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteTodo class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeleteTodo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Id\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteTodos

@implementation DeleteTodos

@dynamic idsArray, idsArray_Count;

typedef struct DeleteTodos__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *idsArray;
} DeleteTodos__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = DeleteTodos_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DeleteTodos__storage_, idsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteTodos class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeleteTodos__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Ids\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmptyResponse

@implementation EmptyResponse

@dynamic hasResponseStatus, responseStatus;

typedef struct EmptyResponse__storage_ {
  uint32_t _has_storage_[1];
  ResponseStatus *responseStatus;
} EmptyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = EmptyResponse_FieldNumber_ResponseStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmptyResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmptyResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmptyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileContent

@implementation FileContent

@dynamic name;
@dynamic type;
@dynamic length;
@dynamic body;
@dynamic hasResponseStatus, responseStatus;

typedef struct FileContent__storage_ {
  uint32_t _has_storage_[1];
  int32_t length;
  NSString *name;
  NSString *type;
  NSData *body;
  ResponseStatus *responseStatus;
} FileContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = FileContent_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FileContent__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = FileContent_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FileContent__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "length",
        .dataTypeSpecific.className = NULL,
        .number = FileContent_FieldNumber_Length,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FileContent__storage_, length),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = FileContent_FieldNumber_Body,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FileContent__storage_, body),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = FileContent_FieldNumber_ResponseStatus,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FileContent__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FileContent class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001D\000\002D\000\003F\000\004D\000\005N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccessToken

@implementation GetAccessToken

@dynamic refreshToken;
@dynamic useTokenCookie;
@dynamic meta, meta_Count;

typedef struct GetAccessToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *refreshToken;
  NSMutableDictionary *meta;
} GetAccessToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "refreshToken",
        .dataTypeSpecific.className = NULL,
        .number = GetAccessToken_FieldNumber_RefreshToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccessToken__storage_, refreshToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "useTokenCookie",
        .dataTypeSpecific.className = NULL,
        .number = GetAccessToken_FieldNumber_UseTokenCookie,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = GetAccessToken_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetAccessToken__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccessToken class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccessToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002N\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccessTokenResponse

@implementation GetAccessTokenResponse

@dynamic accessToken;
@dynamic meta, meta_Count;
@dynamic hasResponseStatus, responseStatus;

typedef struct GetAccessTokenResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *accessToken;
  NSMutableDictionary *meta;
  ResponseStatus *responseStatus;
} GetAccessTokenResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accessToken",
        .dataTypeSpecific.className = NULL,
        .number = GetAccessTokenResponse_FieldNumber_AccessToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccessTokenResponse__storage_, accessToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = GetAccessTokenResponse_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetAccessTokenResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = GetAccessTokenResponse_FieldNumber_ResponseStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAccessTokenResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccessTokenResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccessTokenResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002D\000\003N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTodo

@implementation GetTodo

@dynamic id_p;

typedef struct GetTodo__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
} GetTodo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GetTodo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTodo__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTodo class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTodo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Id\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTodoResponse

@implementation GetTodoResponse

@dynamic hasResult, result;
@dynamic hasResponseStatus, responseStatus;

typedef struct GetTodoResponse__storage_ {
  uint32_t _has_storage_[1];
  Todo *result;
  ResponseStatus *responseStatus;
} GetTodoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = GPBStringifySymbol(Todo),
        .number = GetTodoResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTodoResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = GetTodoResponse_FieldNumber_ResponseStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTodoResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTodoResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTodoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001F\000\002N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTodos

@implementation GetTodos


typedef struct GetTodos__storage_ {
  uint32_t _has_storage_[1];
} GetTodos__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTodos class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetTodos__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTodosResponse

@implementation GetTodosResponse

@dynamic resultsArray, resultsArray_Count;
@dynamic hasResponseStatus, responseStatus;

typedef struct GetTodosResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *resultsArray;
  ResponseStatus *responseStatus;
} GetTodosResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resultsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Todo),
        .number = GetTodosResponse_FieldNumber_ResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetTodosResponse__storage_, resultsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = GetTodosResponse_FieldNumber_ResponseStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTodosResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTodosResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTodosResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000Results\000\002N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Hello

@implementation Hello

@dynamic name;

typedef struct Hello__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} Hello__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Hello_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Hello__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Hello class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Hello__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HelloResponse

@implementation HelloResponse

@dynamic result;
@dynamic hasResponseStatus, responseStatus;

typedef struct HelloResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *result;
  ResponseStatus *responseStatus;
} HelloResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = HelloResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HelloResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = HelloResponse_FieldNumber_ResponseStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HelloResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HelloResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001F\000\002N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HelloSecure

@implementation HelloSecure

@dynamic name;

typedef struct HelloSecure__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} HelloSecure__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = HelloSecure_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HelloSecure__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HelloSecure class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloSecure__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Register

@implementation Register

@dynamic userName;
@dynamic firstName;
@dynamic lastName;
@dynamic displayName;
@dynamic email;
@dynamic password;
@dynamic confirmPassword;
@dynamic autoLogin;
@dynamic continue_p;
@dynamic errorView;
@dynamic meta, meta_Count;

typedef struct Register__storage_ {
  uint32_t _has_storage_[1];
  NSString *userName;
  NSString *firstName;
  NSString *lastName;
  NSString *displayName;
  NSString *email;
  NSString *password;
  NSString *confirmPassword;
  NSString *continue_p;
  NSString *errorView;
  NSMutableDictionary *meta;
} Register__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Register__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firstName",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_FirstName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Register__storage_, firstName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastName",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_LastName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Register__storage_, lastName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_DisplayName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Register__storage_, displayName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_Email,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Register__storage_, email),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_Password,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Register__storage_, password),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "confirmPassword",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_ConfirmPassword,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Register__storage_, confirmPassword),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "autoLogin",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_AutoLogin,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "continue_p",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_Continue_p,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Register__storage_, continue_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "errorView",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_ErrorView,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Register__storage_, errorView),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = Register_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Register__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Register class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Register__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\001H\000\002I\000\003H\000\004K\000\005E\000\006H\000\007O\000\010I\000\t\000Continue\000\nI\000\013"
        "D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterResponse

@implementation RegisterResponse

@dynamic userId;
@dynamic sessionId;
@dynamic userName;
@dynamic referrerURL;
@dynamic bearerToken;
@dynamic refreshToken;
@dynamic hasResponseStatus, responseStatus;
@dynamic meta, meta_Count;

typedef struct RegisterResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *sessionId;
  NSString *userName;
  NSString *referrerURL;
  NSString *bearerToken;
  NSString *refreshToken;
  ResponseStatus *responseStatus;
  NSMutableDictionary *meta;
} RegisterResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RegisterResponse_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterResponse__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = RegisterResponse_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterResponse__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = RegisterResponse_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RegisterResponse__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "referrerURL",
        .dataTypeSpecific.className = NULL,
        .number = RegisterResponse_FieldNumber_ReferrerURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RegisterResponse__storage_, referrerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bearerToken",
        .dataTypeSpecific.className = NULL,
        .number = RegisterResponse_FieldNumber_BearerToken,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RegisterResponse__storage_, bearerToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refreshToken",
        .dataTypeSpecific.className = NULL,
        .number = RegisterResponse_FieldNumber_RefreshToken,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RegisterResponse__storage_, refreshToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = RegisterResponse_FieldNumber_ResponseStatus,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RegisterResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = RegisterResponse_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RegisterResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001F\000\002I\000\003H\000\004I!!\000\005K\000\006L\000\007N\000\010D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResetTodos

@implementation ResetTodos


typedef struct ResetTodos__storage_ {
  uint32_t _has_storage_[1];
} ResetTodos__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResetTodos class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ResetTodos__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseError

@implementation ResponseError

@dynamic errorCode;
@dynamic fieldName;
@dynamic message;
@dynamic meta, meta_Count;

typedef struct ResponseError__storage_ {
  uint32_t _has_storage_[1];
  NSString *errorCode;
  NSString *fieldName;
  NSString *message;
  NSMutableDictionary *meta;
} ResponseError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.className = NULL,
        .number = ResponseError_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseError__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fieldName",
        .dataTypeSpecific.className = NULL,
        .number = ResponseError_FieldNumber_FieldName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseError__storage_, fieldName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = ResponseError_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseError__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = ResponseError_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseError__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseError class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseError__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001I\000\002I\000\003G\000\004D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseStatus

@implementation ResponseStatus

@dynamic errorCode;
@dynamic message;
@dynamic stackTrace;
@dynamic errorsArray, errorsArray_Count;
@dynamic meta, meta_Count;

typedef struct ResponseStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *errorCode;
  NSString *message;
  NSString *stackTrace;
  NSMutableArray *errorsArray;
  NSMutableDictionary *meta;
} ResponseStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.className = NULL,
        .number = ResponseStatus_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseStatus__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = ResponseStatus_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseStatus__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stackTrace",
        .dataTypeSpecific.className = NULL,
        .number = ResponseStatus_FieldNumber_StackTrace,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseStatus__storage_, stackTrace),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "errorsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseError),
        .number = ResponseStatus_FieldNumber_ErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseStatus__storage_, errorsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = ResponseStatus_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseStatus__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseStatus class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001I\000\002G\000\003J\000\004\000Errors\000\005D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StreamFiles

@implementation StreamFiles

@dynamic pathsArray, pathsArray_Count;

typedef struct StreamFiles__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pathsArray;
} StreamFiles__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pathsArray",
        .dataTypeSpecific.className = NULL,
        .number = StreamFiles_FieldNumber_PathsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StreamFiles__storage_, pathsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StreamFiles class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StreamFiles__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Paths\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StreamServerEvents

@implementation StreamServerEvents

@dynamic channelsArray, channelsArray_Count;

typedef struct StreamServerEvents__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelsArray;
} StreamServerEvents__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEvents_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StreamServerEvents__storage_, channelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StreamServerEvents class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StreamServerEvents__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Channels\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StreamServerEventsResponse

@implementation StreamServerEventsResponse

@dynamic eventId;
@dynamic channel;
@dynamic selector;
@dynamic json;
@dynamic op;
@dynamic target;
@dynamic cssSelector;
@dynamic meta, meta_Count;
@dynamic userId;
@dynamic displayName;
@dynamic profileURL;
@dynamic isAuthenticated;
@dynamic channelsArray, channelsArray_Count;
@dynamic createdAt;
@dynamic id_p;
@dynamic unRegisterURL;
@dynamic updateSubscriberURL;
@dynamic heartbeatURL;
@dynamic heartbeatIntervalMs;
@dynamic idleTimeoutMs;
@dynamic hasResponseStatus, responseStatus;

typedef struct StreamServerEventsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *channel;
  NSString *selector;
  NSString *json;
  NSString *op;
  NSString *target;
  NSString *cssSelector;
  NSMutableDictionary *meta;
  NSString *userId;
  NSString *displayName;
  NSString *profileURL;
  NSMutableArray *channelsArray;
  NSString *id_p;
  NSString *unRegisterURL;
  NSString *updateSubscriberURL;
  NSString *heartbeatURL;
  ResponseStatus *responseStatus;
  int64_t eventId;
  int64_t createdAt;
  int64_t heartbeatIntervalMs;
  int64_t idleTimeoutMs;
} StreamServerEventsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventId",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_EventId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, eventId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_Channel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, channel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selector",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_Selector,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, selector),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "json",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_Json,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, json),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "op",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_Op,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, op),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_Target,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, target),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cssSelector",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_CssSelector,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, cssSelector),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_UserId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_DisplayName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, displayName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "profileURL",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_ProfileURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, profileURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAuthenticated",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_IsAuthenticated,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, channelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_CreatedAt,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, createdAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_Id_p,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unRegisterURL",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_UnRegisterURL,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, unRegisterURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "updateSubscriberURL",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_UpdateSubscriberURL,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, updateSubscriberURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "heartbeatURL",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_HeartbeatURL,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, heartbeatURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "heartbeatIntervalMs",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_HeartbeatIntervalMs,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, heartbeatIntervalMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "idleTimeoutMs",
        .dataTypeSpecific.className = NULL,
        .number = StreamServerEventsResponse_FieldNumber_IdleTimeoutMs,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, idleTimeoutMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = StreamServerEventsResponse_FieldNumber_ResponseStatus,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(StreamServerEventsResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StreamServerEventsResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StreamServerEventsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\025\001G\000\002G\000\004H\000\005D\000\006B\000\007F\000\010K\000\tD\000\nF\000\013K\000\014H!!\000\rO\000\016"
        "\000Channels\000\017I\000\025\000Id\000\026K!!\000\027Q!!\000\030J!!\000\031S\000\032M\000\036"
        "N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Todo

@implementation Todo

@dynamic id_p;
@dynamic title;
@dynamic order;
@dynamic completed;

typedef struct Todo__storage_ {
  uint32_t _has_storage_[1];
  int32_t order;
  NSString *title;
  int64_t id_p;
} Todo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Todo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Todo__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = Todo_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Todo__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "order",
        .dataTypeSpecific.className = NULL,
        .number = Todo_FieldNumber_Order,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Todo__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "completed",
        .dataTypeSpecific.className = NULL,
        .number = Todo_FieldNumber_Completed,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Todo class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Todo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\000Id\000\002E\000\003E\000\004I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnAssignRoles

@implementation UnAssignRoles

@dynamic userName;
@dynamic permissionsArray, permissionsArray_Count;
@dynamic rolesArray, rolesArray_Count;
@dynamic meta, meta_Count;

typedef struct UnAssignRoles__storage_ {
  uint32_t _has_storage_[1];
  NSString *userName;
  NSMutableArray *permissionsArray;
  NSMutableArray *rolesArray;
  NSMutableDictionary *meta;
} UnAssignRoles__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = UnAssignRoles_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnAssignRoles__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permissionsArray",
        .dataTypeSpecific.className = NULL,
        .number = UnAssignRoles_FieldNumber_PermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnAssignRoles__storage_, permissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rolesArray",
        .dataTypeSpecific.className = NULL,
        .number = UnAssignRoles_FieldNumber_RolesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnAssignRoles__storage_, rolesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = UnAssignRoles_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnAssignRoles__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnAssignRoles class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnAssignRoles__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001H\000\002\000Permissions\000\003\000Roles\000\004D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnAssignRolesResponse

@implementation UnAssignRolesResponse

@dynamic allRolesArray, allRolesArray_Count;
@dynamic allPermissionsArray, allPermissionsArray_Count;
@dynamic meta, meta_Count;
@dynamic hasResponseStatus, responseStatus;

typedef struct UnAssignRolesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *allRolesArray;
  NSMutableArray *allPermissionsArray;
  NSMutableDictionary *meta;
  ResponseStatus *responseStatus;
} UnAssignRolesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "allRolesArray",
        .dataTypeSpecific.className = NULL,
        .number = UnAssignRolesResponse_FieldNumber_AllRolesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnAssignRolesResponse__storage_, allRolesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "allPermissionsArray",
        .dataTypeSpecific.className = NULL,
        .number = UnAssignRolesResponse_FieldNumber_AllPermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnAssignRolesResponse__storage_, allPermissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = NULL,
        .number = UnAssignRolesResponse_FieldNumber_Meta,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnAssignRolesResponse__storage_, meta),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "responseStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseStatus),
        .number = UnAssignRolesResponse_FieldNumber_ResponseStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnAssignRolesResponse__storage_, responseStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnAssignRolesResponse class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnAssignRolesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\000AllRoles\000\002\000AllPermissions\000\003D\000\004N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateTodo

@implementation UpdateTodo

@dynamic id_p;
@dynamic title;
@dynamic order;
@dynamic completed;

typedef struct UpdateTodo__storage_ {
  uint32_t _has_storage_[1];
  int32_t order;
  NSString *title;
  int64_t id_p;
} UpdateTodo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = UpdateTodo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateTodo__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = UpdateTodo_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateTodo__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "order",
        .dataTypeSpecific.className = NULL,
        .number = UpdateTodo_FieldNumber_Order,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateTodo__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "completed",
        .dataTypeSpecific.className = NULL,
        .number = UpdateTodo_FieldNumber_Completed,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateTodo class]
                                     rootClass:[ServicesRoot class]
                                          file:ServicesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateTodo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\000Id\000\002E\000\003E\000\004I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
